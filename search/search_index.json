{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"<p>  <p>I'm Marcelo, nice to meet you! \ud83d\udc4b</p> </p>  <p> I'm a software engineer from Brazil. \ud83c\udde7\ud83c\uddf7 </p> <p> I'm currently living in Utrecht, Netherlands. \ud83c\uddf3\ud83c\uddf1 </p> <p> I'm a maintainer of Starlette and Uvicorn. </p> <p> I'm also a FastAPI Expert. </p> <p>If my open source work is useful to you, consider sponsoring me. \ud83d\ude4f</p> <p>  </p>","title":"Marcelo's Blog"},{"location":"./2022/09/20/fastapi-escape-character/","text":"<p>Today, we'll talk about a small feature of FastAPI that might be useful for you: the escape character. </p>","title":"FastAPI Escape Character"},{"location":"./2022/09/20/fastapi-escape-character/#what-is-the-escape-character","text":"<p>The escape character <code>\\f</code> is a character that can be used to tell to FastAPI to truncate what should go to the endpoint description on the OpenAPI.</p> <p>Let's see it in practice. Consider we have the following endpoint:</p> CodeRun   main.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef home():\n    \"\"\"This is home.\n    \\f\n    This is not on the OpenAPI.\n    \"\"\"\n</code></pre>   <p>Install the dependencies:</p> <pre><code>python -m pip install uvicorn fastapi\n</code></pre> <p>Then run <code>uvicorn</code>:</p> <pre><code>uvicorn main:app\n</code></pre>     <p>When we call the <code>/openapi.json</code> endpoint:</p> <pre><code>http GET :8000/openapi.json  # (1)!\n</code></pre> <ol> <li>The HTTP client used is called HTTPie, but you can use <code>curl</code>,     or just go to the browser, and access <code>http://localhost:8000/openapi.json</code>.</li> </ol> <p>You'll see the following OpenAPI JSON on the response:</p> <pre><code>{\n    \"info\": {\n        \"title\": \"FastAPI\",\n        \"version\": \"0.1.0\"\n    },\n    \"openapi\": \"3.0.2\",\n    \"paths\": {\n        \"/\": {\n            \"get\": {\n                \"description\": \"This is home.\",\n                \"operationId\": \"home__get\",\n                \"responses\": {\n                    \"200\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {}\n                            }\n                        },\n                        \"description\": \"Successful Response\"\n                    }\n                },\n                \"summary\": \"Home\"\n            }\n        }\n    }\n}\n</code></pre> <p>Observe the \"description\" field does not contain the \"This is not on OpenAPI\" part of the docstring. The reason is the escape character we used. Everything after the <code>\\f</code> will not appear on that field.</p> <p>This feature may be useful if you are using a docstring linter tool, like darglint.</p>","title":"What is the escape character?"},{"location":"./2022/09/20/fastapi-escape-character/#whats-new","text":"<p>If you are a FastAPI veteran (), you are probably familiar with the above. What you probably don't know, is that now (since FastAPI 0.82.0) it's possible to use it on the Pydantic models you use on your FastAPI application.</p> <p>Let's see another example.</p> CodeRun   <p>As most of my examples, we'll use potatoes:</p> main.py<pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass PotatoOutput(BaseModel):\n    \"\"\"Super potato.\n    \\f\n    This is not on the OpenAPI.\n    \"\"\"\n\n@app.get(\"/\", response_model=PotatoOutput)\ndef get_potato():\n    ...\n</code></pre>   <p>Install the dependencies:</p> <pre><code>python -m pip install uvicorn fastapi\n</code></pre> <p>Then run <code>uvicorn</code>:</p> <pre><code>uvicorn main:app\n</code></pre>    <p>When we call <code>/openapi.json</code>, as we did above, we'll get the following OpenAPI JSON as response:</p> <pre><code>{\n    \"components\": {\n        \"schemas\": {\n            \"PotatoOutput\": {\n                \"description\": \"Super potato.\\n\",\n                \"properties\": {},\n                \"title\": \"PotatoOutput\",\n                \"type\": \"object\"\n            }\n        }\n    },\n    \"info\": {\n        \"title\": \"FastAPI\",\n        \"version\": \"0.1.0\"\n    },\n    \"openapi\": \"3.0.2\",\n    \"paths\": {\n        \"/\": {\n            \"get\": {\n                \"operationId\": \"get_potato__get\",\n                \"responses\": {\n                    \"200\": {\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/PotatoOutput\"\n                                }\n                            }\n                        },\n                        \"description\": \"Successful Response\"\n                    }\n                },\n                \"summary\": \"Get Potato\"\n            }\n        }\n    }\n}\n</code></pre>  <p>Tip</p> <p>We can also use <code>jq</code> to get the part of the JSON that we are interested.</p> CallOutput   <pre><code>http GET :8000/openapi.json | jq .components.schemas\n</code></pre>   <pre><code>{\n    \"PotatoOutput\": {\n        \"title\": \"PotatoOutput\",\n        \"type\": \"object\",\n        \"properties\": {},\n        \"description\": \"Super potato.\\n\"\n    }\n}\n</code></pre>     <p>As we can see, the description of <code>PotatoOutput</code> doesn't contain the \"This is not on the OpenAPI.\" part as well.</p> <p>Yey! Now you can use those docstring linter tools as you want with FastAPI! </p>  <p>Thanks for reading this blog post! </p> <p>If you have any suggestions on what I can write about, please feel free to suggest below. </p>","title":"What's new?"},{"location":"./2022/09/13/fastapis-test-client/","text":"<p>This is my first blog post! </p> <p>Please enjoy, and let me know if you have any feedback. </p>  <p>Abstract</p> <p>If you are new to FastAPI, you might benefit from reading the following:</p> <ul> <li><code>TestClient</code> origin and features</li> <li>The <code>TestClient</code> weird behavior</li> </ul> <p>If you already know stuff about FastAPI, you might jump to:</p> <ul> <li>The Future of the <code>TestClient</code></li> </ul>  <p>Today, we'll talk about the main tool for testing FastAPI applications: the <code>TestClient</code>.</p>","title":"FastAPI's Test Client"},{"location":"./2022/09/13/fastapis-test-client/#testclient-origin-and-features","text":"<p>The <code>TestClient</code> is a feature from Starlette (one of the two main dependencies of FastAPI). On which, FastAPI only does a reimport on the <code>testclient</code> module, as we can see here.</p> <p>We can use the <code>TestClient</code> to test our WebSocket and HTTP endpoints.</p>","title":"<code>TestClient</code> origin and features"},{"location":"./2022/09/13/fastapis-test-client/#the-testclient-weird-behavior","text":"<p>Although documented on both FastAPI and Starlette's documentation, most of the people are not aware of the <code>TestClient</code>'s behavior when it comes to events. To put it simple, there are two ways of creating a <code>TestClient</code> object, and in one of those ways, the events are not executed.</p> <p>Let's see the behavior with the following FastAPI application:</p> main.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\nstarted = False\n\n@app.on_event(\"startup\") # (1)!\ndef startup():\n    global started\n    started = True\n\n@app.get(\"/\")\ndef home():\n    if started:\n        return {\"message\": \"STARTED\"}\n    else:\n        return {\"message\": \"NOT STARTED\"}\n</code></pre> <ol> <li> <p>There are only two events available: startup and shutdown.</p> <p>Read more about it on the ASGI documentation.</p> </li> </ol> <p>As you can see, there's a single endpoint, which gives us a different message depending on the value of the <code>started</code> variable. The <code>started</code> variable is set to <code>True</code> on the <code>startup</code> event.</p> <p>Now, let's test it with the <code>TestClient</code>:</p> CodeRun   test.py<pre><code>from fastapi.testclient import TestClient\n\nfrom main import app\n\ndef test_home():\n    client = TestClient(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"NOT STARTED\"}\n</code></pre>   <p>Install the dependencies:</p> <pre><code>python -m pip install \"fastapi[all]\" pytest\n</code></pre> <p>Then run <code>pytest</code>: <pre><code>pytest test.py\n</code></pre></p>     <p>As you can see, the above test passes. Which means the <code>startup</code> event was not triggered. </p> <p>On the other hand, if we run the following test, we'll get a different result:</p> CodeRun   test.py<pre><code>from fastapi.testclient import TestClient\n\nfrom main import app\n\ndef test_home():\n    with TestClient(app):\n        response = client.get(\"/\")\n        assert response.status_code == 200\n        assert response.json() == {\"message\": \"STARTED\"}\n</code></pre>   <p>Install the dependencies:</p> <pre><code>python -m pip install \"fastapi[all]\" pytest\n</code></pre> <p>Then run <code>pytest</code>: <pre><code>pytest test.py\n</code></pre></p>     <p>When used as context manager, the <code>TestClient</code> will trigger the <code>startup</code> event.</p>","title":"The <code>TestClient</code> weird behavior"},{"location":"./2022/09/13/fastapis-test-client/#the-future-of-the-testclient","text":"<p>By the moment I'm writing this blog, the latest FastAPI version is <code>0.83.0</code> with Starlette pinned on <code>0.19.1</code>. Starlette is already on version <code>0.20.3</code>, and the next release will change the internals of the <code>TestClient</code>. To be more specific, the HTTP client will be changed from <code>requests</code> to <code>httpx</code>.</p> <p>As there are some differences between the two clients, the <code>TestClient</code> will reflect the same differences.</p> <p>This change will be in Starlette on version <code>0.21.0</code>, and I'm unsure when it will land on FastAPI.</p> <p>Let's see the changes you should be aware:</p> <ol> <li><code>allow_redirects</code> will be now called <code>follow_redirects</code>.</li> <li><code>cookies</code> parameter will be deprecated under method calls (it should be used on the client instantiation).</li> <li><code>data</code> parameter will be called <code>content</code> when sending bytes or text.</li> <li><code>content_type</code> will default to \"text/plain\" when sending file instead of empty string.</li> <li>The HTTP methods DELETE, GET, HEAD and OPTIONS will not accept <code>content</code>, <code>data</code>, <code>json</code> and <code>files</code> parameters.</li> <li> <p><code>data</code> parameter doesn't accept list of tuples, instead it should be a dictionary.</p> \u274c List of Tuples\u2705 Dictionary   <pre><code>client.post(..., data=[(\"key1\", \"1\"), (\"key1\", \"2\"), (\"key2\", \"3\")])\n</code></pre>   <pre><code>client.post(..., data={\"key1\": [\"1\", \"2\"], \"key2\": \"3\"})\n</code></pre>    </li> </ol> <p>Those changes will likely impact your test suite. Having this in mind, I've created a codemod that will help you to migrate your tests: bump-testclient. </p> <p>Here is the list of what the codemod will do:</p> <ol> <li>Replace <code>allow_redirects</code> with <code>follow_redirects</code>.</li> <li>Replace <code>data</code> with <code>content</code> when sending bytes or text.</li> <li>Replace <code>client.&lt;method&gt;(..., &lt;parameter&gt;=...)</code> by <code>client.request(\"&lt;method&gt;\", ..., &lt;parameter&gt;=...)</code> when parameter is either    <code>content</code>, <code>data</code>, <code>json</code> or <code>files</code>.</li> </ol> <p>In case you want to read more about the differences between the underneath clients, you can check the httpx documentation.</p> <p>Thanks for reading till here! </p>","title":"The Future of the <code>TestClient</code>"}]}